"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "(pages-dir-browser)/./hooks/useTweets.ts":
/*!****************************!*\
  !*** ./hooks/useTweets.ts ***!
  \****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useTweets: () => (/* binding */ useTweets)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n// frontend/hooks/useTweets.ts\n\n// Mock tweets data for offline development\nconst MOCK_TWEETS = [\n    {\n        id: 1,\n        original_text: \"I thinked about going to the store yesterday but I forgeted.\",\n        corrected_text: \"I thought about going to the store yesterday but I forgot.\",\n        explanation: \"The past tense of 'think' is 'thought', not 'thinked'. Similarly, the past tense of 'forget' is 'forgot', not 'forgeted'.\",\n        created_at: new Date().toISOString(),\n        user_id: 1\n    },\n    {\n        id: 2,\n        original_text: \"I have been studing english for 2 years and im getting better everyday.\",\n        corrected_text: \"I have been studying English for 2 years and I'm getting better every day.\",\n        explanation: \"The correct spelling is 'studying' (not 'studing'), 'English' should be capitalized, and 'everyday' should be two words ('every day') in this context.\",\n        created_at: new Date().toISOString(),\n        user_id: 1\n    }\n];\nfunction useTweets() {\n    const [tweets, setTweets] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [offlineMode, setOfflineMode] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    // Fetch tweets on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useTweets.useEffect\": ()=>{\n            fetchTweets();\n        }\n    }[\"useTweets.useEffect\"], []);\n    // Function to fetch tweets\n    const fetchTweets = async ()=>{\n        try {\n            setIsLoading(true);\n            setError(null);\n            const apiUrl = \"http://localhost:8000\" || 0;\n            const token = localStorage.getItem('authToken');\n            console.log(\"Fetching tweets with token:\", token ? \"exists\" : \"does not exist\");\n            if (!token) {\n                throw new Error('Not authenticated');\n            }\n            try {\n                // Try to fetch from API\n                const response = await fetch(\"\".concat(apiUrl, \"/api/v1/tweets/\"), {\n                    method: 'GET',\n                    headers: {\n                        'Content-Type': 'application/json',\n                        'Authorization': \"Bearer \".concat(token)\n                    },\n                    // Short timeout to quickly fall back to mock data if API is unavailable\n                    signal: AbortSignal.timeout(3000)\n                });\n                if (!response.ok) {\n                    throw new Error('Failed to fetch tweets');\n                }\n                let data = await response.json();\n                // Sort tweets by created_at, newest first\n                data.sort((a, b)=>new Date(b.created_at).getTime() - new Date(a.created_at).getTime());\n                console.log(\"Tweets fetched successfully:\", data);\n                setTweets(data);\n                setOfflineMode(false);\n            } catch (fetchError) {\n                console.warn('Falling back to mock data:', fetchError);\n                // Fall back to mock data\n                // Sort MOCK_TWEETS by created_at, newest first\n                const sortedMockTweets = [\n                    ...MOCK_TWEETS\n                ].sort((a, b)=>new Date(b.created_at).getTime() - new Date(a.created_at).getTime());\n                setTweets(sortedMockTweets);\n                setOfflineMode(true);\n            }\n        } catch (err) {\n            console.error('Error in tweet handling:', err);\n            setError(err instanceof Error ? err : new Error('Unknown error'));\n            // Fallback to mock data even in case of errors\n            // Sort MOCK_TWEETS by created_at, newest first\n            const sortedMockTweets = [\n                ...MOCK_TWEETS\n            ].sort((a, b)=>new Date(b.created_at).getTime() - new Date(a.created_at).getTime());\n            setTweets(sortedMockTweets);\n            setOfflineMode(true);\n        } finally{\n            setIsLoading(false);\n        }\n    };\n    // Function to create a tweet\n    const createTweet = async (originalText)=>{\n        try {\n            // For offline mode, create a mock tweet\n            if (offlineMode) {\n                console.log(\"Creating tweet in offline mode\");\n                // Create a mock correction (simulating AI)\n                let correctedText = originalText;\n                let explanation = \"Great job! Your English is perfect in this tweet.\";\n                // Simple offline corrections for demo purposes\n                if (originalText.includes(\"thinked\")) {\n                    correctedText = originalText.replace(\"thinked\", \"thought\");\n                    explanation = \"The past tense of 'think' is 'thought', not 'thinked'.\";\n                } else if (originalText.includes(\"im \")) {\n                    correctedText = originalText.replace(\"im \", \"I'm \");\n                    explanation = \"The contraction of 'I am' is 'I'm', not 'im'.\";\n                } else if (originalText.includes(\"everyday\")) {\n                    correctedText = originalText.replace(\"everyday\", \"every day\");\n                    explanation = \"'Everyday' (one word) is an adjective meaning 'ordinary'. You need 'every day' (two words) when referring to each day.\";\n                }\n                const newTweet = {\n                    id: Math.max(0, ...tweets.map((t)=>t.id)) + 1,\n                    original_text: originalText,\n                    corrected_text: correctedText,\n                    explanation: explanation,\n                    created_at: new Date().toISOString(),\n                    user_id: 1\n                };\n                // Update tweets list - correctly add to beginning of array\n                setTweets((prevTweets)=>[\n                        newTweet,\n                        ...prevTweets\n                    ]);\n                return newTweet;\n            }\n            // Online mode - try to call API\n            const apiUrl = \"http://localhost:8000\" || 0;\n            const token = localStorage.getItem('authToken');\n            console.log(\"Creating tweet with token:\", token ? \"exists\" : \"does not exist\");\n            if (!token) {\n                throw new Error('Not authenticated');\n            }\n            try {\n                const response = await fetch(\"\".concat(apiUrl, \"/api/v1/tweets/\"), {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json',\n                        'Authorization': \"Bearer \".concat(token)\n                    },\n                    body: JSON.stringify({\n                        original_text: originalText\n                    }),\n                    signal: AbortSignal.timeout(5000) // 5 second timeout\n                });\n                if (!response.ok) {\n                    throw new Error('Failed to create tweet');\n                }\n                const newTweet = await response.json();\n                console.log(\"Tweet created successfully:\", newTweet);\n                // Update tweets list - ensure it's added to the beginning\n                setTweets((prevTweets)=>[\n                        newTweet,\n                        ...prevTweets\n                    ]);\n                return newTweet;\n            } catch (fetchError) {\n                console.warn('Falling back to mock creation:', fetchError);\n                // Fall back to mock creation\n                setOfflineMode(true);\n                // Call the function again, which will now use offline mode\n                return createTweet(originalText);\n            }\n        } catch (error) {\n            console.error('Error creating tweet:', error);\n            throw error;\n        }\n    };\n    return {\n        tweets,\n        isLoading,\n        error,\n        createTweet,\n        refreshTweets: fetchTweets,\n        offlineMode\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QU8sQ0FBQztZQUVuQ0MsUUFBUUMsR0FBRyxDQUFDLDhCQUE4QkosUUFBUSxXQUFXO1lBRTdELElBQUksQ0FBQ0EsT0FBTztnQkFDVixNQUFNLElBQUlLLE1BQU07WUFDbEI7WUFFQSxJQUFJO2dCQUNGLE1BQU1DLFdBQVcsTUFBTUMsTUFBTSxHQUFVLE9BQVBYLFFBQU8sb0JBQWtCO29CQUN2RFksUUFBUTtvQkFDUkMsU0FBUzt3QkFDUCxnQkFBZ0I7d0JBQ2hCLGlCQUFpQixVQUFnQixPQUFOVDtvQkFDN0I7b0JBQ0FtQyxNQUFNQyxLQUFLQyxTQUFTLENBQUM7d0JBQUUxRCxlQUFlOEM7b0JBQWE7b0JBQ25EZixRQUFRQyxZQUFZQyxPQUFPLENBQUMsTUFBTSxtQkFBbUI7Z0JBQ3ZEO2dCQUVBLElBQUksQ0FBQ04sU0FBU08sRUFBRSxFQUFFO29CQUNoQixNQUFNLElBQUlSLE1BQU07Z0JBQ2xCO2dCQUVBLE1BQU13QixXQUFXLE1BQU12QixTQUFTUyxJQUFJO2dCQUNwQ1osUUFBUUMsR0FBRyxDQUFDLCtCQUErQnlCO2dCQUUzQywwREFBMEQ7Z0JBQzFEekMsVUFBVThDLENBQUFBLGFBQWM7d0JBQUNMOzJCQUFhSztxQkFBVztnQkFFakQsT0FBT0w7WUFDVCxFQUFFLE9BQU9ULFlBQVk7Z0JBQ25CakIsUUFBUWtCLElBQUksQ0FBQyxrQ0FBa0NEO2dCQUMvQyw2QkFBNkI7Z0JBQzdCMUIsZUFBZTtnQkFDZiwyREFBMkQ7Z0JBQzNELE9BQU84QixZQUFZQztZQUNyQjtRQUNGLEVBQUUsT0FBT2xDLE9BQU87WUFDZFksUUFBUVosS0FBSyxDQUFDLHlCQUF5QkE7WUFDdkMsTUFBTUE7UUFDUjtJQUNGO0lBRUEsT0FBTztRQUNMSjtRQUNBRTtRQUNBRTtRQUNBaUM7UUFDQWMsZUFBZTNDO1FBQ2ZGO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsiL2hvbWUveGF2aWVyZGV2L2NvZGluZ19wcm9qZWN0cy90d2luZ2xpc2gvZnJvbnRlbmQvaG9va3MvdXNlVHdlZXRzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGZyb250ZW5kL2hvb2tzL3VzZVR3ZWV0cy50c1xuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcblxuZXhwb3J0IGludGVyZmFjZSBUd2VldCB7XG4gIGlkOiBudW1iZXI7XG4gIG9yaWdpbmFsX3RleHQ6IHN0cmluZztcbiAgY29ycmVjdGVkX3RleHQ6IHN0cmluZztcbiAgZXhwbGFuYXRpb246IHN0cmluZztcbiAgY3JlYXRlZF9hdDogc3RyaW5nO1xuICB1c2VyX2lkOiBudW1iZXI7XG59XG5cbi8vIE1vY2sgdHdlZXRzIGRhdGEgZm9yIG9mZmxpbmUgZGV2ZWxvcG1lbnRcbmNvbnN0IE1PQ0tfVFdFRVRTOiBUd2VldFtdID0gW1xuICB7XG4gICAgaWQ6IDEsXG4gICAgb3JpZ2luYWxfdGV4dDogXCJJIHRoaW5rZWQgYWJvdXQgZ29pbmcgdG8gdGhlIHN0b3JlIHllc3RlcmRheSBidXQgSSBmb3JnZXRlZC5cIixcbiAgICBjb3JyZWN0ZWRfdGV4dDogXCJJIHRob3VnaHQgYWJvdXQgZ29pbmcgdG8gdGhlIHN0b3JlIHllc3RlcmRheSBidXQgSSBmb3Jnb3QuXCIsXG4gICAgZXhwbGFuYXRpb246IFwiVGhlIHBhc3QgdGVuc2Ugb2YgJ3RoaW5rJyBpcyAndGhvdWdodCcsIG5vdCAndGhpbmtlZCcuIFNpbWlsYXJseSwgdGhlIHBhc3QgdGVuc2Ugb2YgJ2ZvcmdldCcgaXMgJ2ZvcmdvdCcsIG5vdCAnZm9yZ2V0ZWQnLlwiLFxuICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICB1c2VyX2lkOiAxXG4gIH0sXG4gIHtcbiAgICBpZDogMixcbiAgICBvcmlnaW5hbF90ZXh0OiBcIkkgaGF2ZSBiZWVuIHN0dWRpbmcgZW5nbGlzaCBmb3IgMiB5ZWFycyBhbmQgaW0gZ2V0dGluZyBiZXR0ZXIgZXZlcnlkYXkuXCIsXG4gICAgY29ycmVjdGVkX3RleHQ6IFwiSSBoYXZlIGJlZW4gc3R1ZHlpbmcgRW5nbGlzaCBmb3IgMiB5ZWFycyBhbmQgSSdtIGdldHRpbmcgYmV0dGVyIGV2ZXJ5IGRheS5cIixcbiAgICBleHBsYW5hdGlvbjogXCJUaGUgY29ycmVjdCBzcGVsbGluZyBpcyAnc3R1ZHlpbmcnIChub3QgJ3N0dWRpbmcnKSwgJ0VuZ2xpc2gnIHNob3VsZCBiZSBjYXBpdGFsaXplZCwgYW5kICdldmVyeWRheScgc2hvdWxkIGJlIHR3byB3b3JkcyAoJ2V2ZXJ5IGRheScpIGluIHRoaXMgY29udGV4dC5cIixcbiAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgdXNlcl9pZDogMVxuICB9XG5dO1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlVHdlZXRzKCkge1xuICBjb25zdCBbdHdlZXRzLCBzZXRUd2VldHNdID0gdXNlU3RhdGU8VHdlZXRbXT4oW10pO1xuICBjb25zdCBbaXNMb2FkaW5nLCBzZXRJc0xvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8RXJyb3IgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW29mZmxpbmVNb2RlLCBzZXRPZmZsaW5lTW9kZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG5cbiAgLy8gRmV0Y2ggdHdlZXRzIG9uIG1vdW50XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgZmV0Y2hUd2VldHMoKTtcbiAgfSwgW10pO1xuXG4gIC8vIEZ1bmN0aW9uIHRvIGZldGNoIHR3ZWV0c1xuICBjb25zdCBmZXRjaFR3ZWV0cyA9IGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgICAgc2V0RXJyb3IobnVsbCk7XG4gICAgICBcbiAgICAgIGNvbnN0IGFwaVVybCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9VUkwgfHwgJ2h0dHA6Ly9sb2NhbGhvc3Q6ODAwMCc7XG4gICAgICBjb25zdCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdhdXRoVG9rZW4nKTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coXCJGZXRjaGluZyB0d2VldHMgd2l0aCB0b2tlbjpcIiwgdG9rZW4gPyBcImV4aXN0c1wiIDogXCJkb2VzIG5vdCBleGlzdFwiKTtcbiAgICAgIFxuICAgICAgaWYgKCF0b2tlbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhdXRoZW50aWNhdGVkJyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRyeSB0byBmZXRjaCBmcm9tIEFQSVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke2FwaVVybH0vYXBpL3YxL3R3ZWV0cy9gLCB7XG4gICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7dG9rZW59YCxcbiAgICAgICAgICB9LFxuICAgICAgICAgIC8vIFNob3J0IHRpbWVvdXQgdG8gcXVpY2tseSBmYWxsIGJhY2sgdG8gbW9jayBkYXRhIGlmIEFQSSBpcyB1bmF2YWlsYWJsZVxuICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCgzMDAwKVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCB0d2VldHMnKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgbGV0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIFxuICAgICAgICAvLyBTb3J0IHR3ZWV0cyBieSBjcmVhdGVkX2F0LCBuZXdlc3QgZmlyc3RcbiAgICAgICAgZGF0YS5zb3J0KChhOiBUd2VldCwgYjogVHdlZXQpID0+IG5ldyBEYXRlKGIuY3JlYXRlZF9hdCkuZ2V0VGltZSgpIC0gbmV3IERhdGUoYS5jcmVhdGVkX2F0KS5nZXRUaW1lKCkpO1xuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coXCJUd2VldHMgZmV0Y2hlZCBzdWNjZXNzZnVsbHk6XCIsIGRhdGEpO1xuICAgICAgICBzZXRUd2VldHMoZGF0YSk7XG4gICAgICAgIHNldE9mZmxpbmVNb2RlKGZhbHNlKTtcbiAgICAgIH0gY2F0Y2ggKGZldGNoRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdGYWxsaW5nIGJhY2sgdG8gbW9jayBkYXRhOicsIGZldGNoRXJyb3IpO1xuICAgICAgICAvLyBGYWxsIGJhY2sgdG8gbW9jayBkYXRhXG4gICAgICAgIC8vIFNvcnQgTU9DS19UV0VFVFMgYnkgY3JlYXRlZF9hdCwgbmV3ZXN0IGZpcnN0XG4gICAgICAgIGNvbnN0IHNvcnRlZE1vY2tUd2VldHMgPSBbLi4uTU9DS19UV0VFVFNdLnNvcnQoXG4gICAgICAgICAgKGE6IFR3ZWV0LCBiOiBUd2VldCkgPT4gbmV3IERhdGUoYi5jcmVhdGVkX2F0KS5nZXRUaW1lKCkgLSBuZXcgRGF0ZShhLmNyZWF0ZWRfYXQpLmdldFRpbWUoKVxuICAgICAgICApO1xuICAgICAgICBzZXRUd2VldHMoc29ydGVkTW9ja1R3ZWV0cyk7XG4gICAgICAgIHNldE9mZmxpbmVNb2RlKHRydWUpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gdHdlZXQgaGFuZGxpbmc6JywgZXJyKTtcbiAgICAgIHNldEVycm9yKGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyIDogbmV3IEVycm9yKCdVbmtub3duIGVycm9yJykpO1xuICAgICAgLy8gRmFsbGJhY2sgdG8gbW9jayBkYXRhIGV2ZW4gaW4gY2FzZSBvZiBlcnJvcnNcbiAgICAgIC8vIFNvcnQgTU9DS19UV0VFVFMgYnkgY3JlYXRlZF9hdCwgbmV3ZXN0IGZpcnN0XG4gICAgICBjb25zdCBzb3J0ZWRNb2NrVHdlZXRzID0gWy4uLk1PQ0tfVFdFRVRTXS5zb3J0KFxuICAgICAgICAoYTogVHdlZXQsIGI6IFR3ZWV0KSA9PiBuZXcgRGF0ZShiLmNyZWF0ZWRfYXQpLmdldFRpbWUoKSAtIG5ldyBEYXRlKGEuY3JlYXRlZF9hdCkuZ2V0VGltZSgpXG4gICAgICApO1xuICAgICAgc2V0VHdlZXRzKHNvcnRlZE1vY2tUd2VldHMpO1xuICAgICAgc2V0T2ZmbGluZU1vZGUodHJ1ZSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIEZ1bmN0aW9uIHRvIGNyZWF0ZSBhIHR3ZWV0XG4gIGNvbnN0IGNyZWF0ZVR3ZWV0ID0gYXN5bmMgKG9yaWdpbmFsVGV4dDogc3RyaW5nKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEZvciBvZmZsaW5lIG1vZGUsIGNyZWF0ZSBhIG1vY2sgdHdlZXRcbiAgICAgIGlmIChvZmZsaW5lTW9kZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkNyZWF0aW5nIHR3ZWV0IGluIG9mZmxpbmUgbW9kZVwiKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENyZWF0ZSBhIG1vY2sgY29ycmVjdGlvbiAoc2ltdWxhdGluZyBBSSlcbiAgICAgICAgbGV0IGNvcnJlY3RlZFRleHQgPSBvcmlnaW5hbFRleHQ7XG4gICAgICAgIGxldCBleHBsYW5hdGlvbiA9IFwiR3JlYXQgam9iISBZb3VyIEVuZ2xpc2ggaXMgcGVyZmVjdCBpbiB0aGlzIHR3ZWV0LlwiO1xuICAgICAgICBcbiAgICAgICAgLy8gU2ltcGxlIG9mZmxpbmUgY29ycmVjdGlvbnMgZm9yIGRlbW8gcHVycG9zZXNcbiAgICAgICAgaWYgKG9yaWdpbmFsVGV4dC5pbmNsdWRlcyhcInRoaW5rZWRcIikpIHtcbiAgICAgICAgICBjb3JyZWN0ZWRUZXh0ID0gb3JpZ2luYWxUZXh0LnJlcGxhY2UoXCJ0aGlua2VkXCIsIFwidGhvdWdodFwiKTtcbiAgICAgICAgICBleHBsYW5hdGlvbiA9IFwiVGhlIHBhc3QgdGVuc2Ugb2YgJ3RoaW5rJyBpcyAndGhvdWdodCcsIG5vdCAndGhpbmtlZCcuXCI7XG4gICAgICAgIH0gZWxzZSBpZiAob3JpZ2luYWxUZXh0LmluY2x1ZGVzKFwiaW0gXCIpKSB7XG4gICAgICAgICAgY29ycmVjdGVkVGV4dCA9IG9yaWdpbmFsVGV4dC5yZXBsYWNlKFwiaW0gXCIsIFwiSSdtIFwiKTtcbiAgICAgICAgICBleHBsYW5hdGlvbiA9IFwiVGhlIGNvbnRyYWN0aW9uIG9mICdJIGFtJyBpcyAnSSdtJywgbm90ICdpbScuXCI7XG4gICAgICAgIH0gZWxzZSBpZiAob3JpZ2luYWxUZXh0LmluY2x1ZGVzKFwiZXZlcnlkYXlcIikpIHtcbiAgICAgICAgICBjb3JyZWN0ZWRUZXh0ID0gb3JpZ2luYWxUZXh0LnJlcGxhY2UoXCJldmVyeWRheVwiLCBcImV2ZXJ5IGRheVwiKTtcbiAgICAgICAgICBleHBsYW5hdGlvbiA9IFwiJ0V2ZXJ5ZGF5JyAob25lIHdvcmQpIGlzIGFuIGFkamVjdGl2ZSBtZWFuaW5nICdvcmRpbmFyeScuIFlvdSBuZWVkICdldmVyeSBkYXknICh0d28gd29yZHMpIHdoZW4gcmVmZXJyaW5nIHRvIGVhY2ggZGF5LlwiO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zdCBuZXdUd2VldDogVHdlZXQgPSB7XG4gICAgICAgICAgaWQ6IE1hdGgubWF4KDAsIC4uLnR3ZWV0cy5tYXAodCA9PiB0LmlkKSkgKyAxLFxuICAgICAgICAgIG9yaWdpbmFsX3RleHQ6IG9yaWdpbmFsVGV4dCxcbiAgICAgICAgICBjb3JyZWN0ZWRfdGV4dDogY29ycmVjdGVkVGV4dCxcbiAgICAgICAgICBleHBsYW5hdGlvbjogZXhwbGFuYXRpb24sXG4gICAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIHVzZXJfaWQ6IDFcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSB0d2VldHMgbGlzdCAtIGNvcnJlY3RseSBhZGQgdG8gYmVnaW5uaW5nIG9mIGFycmF5XG4gICAgICAgIHNldFR3ZWV0cyhwcmV2VHdlZXRzID0+IFtuZXdUd2VldCwgLi4ucHJldlR3ZWV0c10pO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIG5ld1R3ZWV0O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBPbmxpbmUgbW9kZSAtIHRyeSB0byBjYWxsIEFQSVxuICAgICAgY29uc3QgYXBpVXJsID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1VSTCB8fCAnaHR0cDovL2xvY2FsaG9zdDo4MDAwJztcbiAgICAgIGNvbnN0IHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2F1dGhUb2tlbicpO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhcIkNyZWF0aW5nIHR3ZWV0IHdpdGggdG9rZW46XCIsIHRva2VuID8gXCJleGlzdHNcIiA6IFwiZG9lcyBub3QgZXhpc3RcIik7XG4gICAgICBcbiAgICAgIGlmICghdG9rZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYXV0aGVudGljYXRlZCcpO1xuICAgICAgfVxuICAgICAgXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke2FwaVVybH0vYXBpL3YxL3R3ZWV0cy9gLCB7XG4gICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3Rva2VufWAsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IG9yaWdpbmFsX3RleHQ6IG9yaWdpbmFsVGV4dCB9KSxcbiAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQoNTAwMCkgLy8gNSBzZWNvbmQgdGltZW91dFxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgdHdlZXQnKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc3QgbmV3VHdlZXQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVHdlZXQgY3JlYXRlZCBzdWNjZXNzZnVsbHk6XCIsIG5ld1R3ZWV0KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSB0d2VldHMgbGlzdCAtIGVuc3VyZSBpdCdzIGFkZGVkIHRvIHRoZSBiZWdpbm5pbmdcbiAgICAgICAgc2V0VHdlZXRzKHByZXZUd2VldHMgPT4gW25ld1R3ZWV0LCAuLi5wcmV2VHdlZXRzXSk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gbmV3VHdlZXQ7XG4gICAgICB9IGNhdGNoIChmZXRjaEVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignRmFsbGluZyBiYWNrIHRvIG1vY2sgY3JlYXRpb246JywgZmV0Y2hFcnJvcik7XG4gICAgICAgIC8vIEZhbGwgYmFjayB0byBtb2NrIGNyZWF0aW9uXG4gICAgICAgIHNldE9mZmxpbmVNb2RlKHRydWUpO1xuICAgICAgICAvLyBDYWxsIHRoZSBmdW5jdGlvbiBhZ2Fpbiwgd2hpY2ggd2lsbCBub3cgdXNlIG9mZmxpbmUgbW9kZVxuICAgICAgICByZXR1cm4gY3JlYXRlVHdlZXQob3JpZ2luYWxUZXh0KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgdHdlZXQ6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB7XG4gICAgdHdlZXRzLFxuICAgIGlzTG9hZGluZyxcbiAgICBlcnJvcixcbiAgICBjcmVhdGVUd2VldCxcbiAgICByZWZyZXNoVHdlZXRzOiBmZXRjaFR3ZWV0cyxcbiAgICBvZmZsaW5lTW9kZVxuICB9O1xufVxuIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlRWZmZWN0IiwiTU9DS19UV0VFVFMiLCJpZCIsIm9yaWdpbmFsX3RleHQiLCJjb3JyZWN0ZWRfdGV4dCIsImV4cGxhbmF0aW9uIiwiY3JlYXRlZF9hdCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInVzZXJfaWQiLCJ1c2VUd2VldHMiLCJ0d2VldHMiLCJzZXRUd2VldHMiLCJpc0xvYWRpbmciLCJzZXRJc0xvYWRpbmciLCJlcnJvciIsInNldEVycm9yIiwib2ZmbGluZU1vZGUiLCJzZXRPZmZsaW5lTW9kZSIsImZldGNoVHdlZXRzIiwiYXBpVXJsIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9VUkwiLCJ0b2tlbiIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJjb25zb2xlIiwibG9nIiwiRXJyb3IiLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsInNpZ25hbCIsIkFib3J0U2lnbmFsIiwidGltZW91dCIsIm9rIiwiZGF0YSIsImpzb24iLCJzb3J0IiwiYSIsImIiLCJnZXRUaW1lIiwiZmV0Y2hFcnJvciIsIndhcm4iLCJzb3J0ZWRNb2NrVHdlZXRzIiwiZXJyIiwiY3JlYXRlVHdlZXQiLCJvcmlnaW5hbFRleHQiLCJjb3JyZWN0ZWRUZXh0IiwiaW5jbHVkZXMiLCJyZXBsYWNlIiwibmV3VHdlZXQiLCJNYXRoIiwibWF4IiwibWFwIiwidCIsInByZXZUd2VldHMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsInJlZnJlc2hUd2VldHMiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./hooks/useTweets.ts\n"));

/***/ })

});